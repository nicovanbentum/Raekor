#version 450

#define Pi 3.1415926535

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform sampler2D prevResult;
layout(binding = 1, rgba16f) uniform image2D resultBuffer;
layout(binding = 2) uniform sampler2D depthTexture;
layout(binding = 3, rg16f) uniform image2D velocityTexture;
layout(binding = 4, rgba16f) uniform image2D source;
layout(binding = 5, rgba16f) uniform image2D historyBuffer;

/*
    From GPU Gems
    https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch24.html
*/
float FilterMitchellNetravali(float x) {
    float B = 1.0 / 3.0;
    float C = 1.0 / 3.0;
    float ax = abs(x);
    if (ax < 1) {
    return ((12 - 9 * B - 6 * C) * ax * ax * ax +
            (-18 + 12 * B + 6 * C) * ax * ax + (6 - 2 * B)) / 6;
    } else if ((ax >= 1) && (ax < 2)) {
        return ((-B - 6 * C) * ax * ax * ax +
                (6 * B + 30 * C) * ax * ax + (-12 * B - 48 * C) *
                ax + (8 * B + 24 * C)) / 6;
    } else {
        return 0;
    }
}

/*
    GLSL version of:
    https://github.com/TheRealMJP/MSAAFilter/blob/master/MSAAFilter/Resolve.hlsl
*/
float FilterBlackmanHarris(in float x) {
    x = 1.0f - x;

    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;
    return clamp(a0 - a1 * cos(Pi * x) + a2 * cos(2 * Pi * x) - a3 * cos(3 * Pi * x), 0.0, 1.0);
}

/*
    GLSL version of:
    https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1
*/
vec4 SampleTextureCatmullRom(in sampler2D tex, vec2 uv, ivec2 texSize) {
    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding
    // down the sample location to get the exact center of our "starting" texel. The starting texel will be at
    // location [1, 1] in the grid, where [0, 0] is the top left corner.
    vec2 samplePos = uv * texSize;
    vec2 texPos1 = floor(samplePos - 0.5f) + 0.5f;

    // Compute the fractional offset from our starting texel to our original sample location, which we'll
    // feed into the Catmull-Rom spline function to get our filter weights.
    vec2 f = samplePos - texPos1;

    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.
    // These equations are pre-expanded based on our knowledge of where the texels will be located,
    // which lets us avoid having to evaluate a piece-wise function.
    vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
    vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
    vec2 w3 = f * f * (-0.5 + 0.5 * f);

    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to
    // simultaneously evaluate the middle 2 samples from the 4x4 grid.
    vec2 w12 = w1 + w2;
    vec2 offset12 = w2 / (w1 + w2);

    // Compute the final UV coordinates we'll use for sampling the texture
    vec2 texPos0 = texPos1 - 1;
    vec2 texPos3 = texPos1 + 2;
    vec2 texPos12 = texPos1 + offset12;

    texPos0 /= texSize;
    texPos3 /= texSize;
    texPos12 /= texSize;

    vec4 result = vec4(0.0);
    
    result += texture(tex, vec2(texPos0.x, texPos0.y)) * w0.x * w0.y;
    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;
    result += texture(tex, vec2(texPos3.x, texPos0.y)) * w3.x * w0.y;

    result += texture(tex, vec2(texPos0.x, texPos12.y)) * w0.x * w12.y;
    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;
    result += texture(tex, vec2(texPos3.x, texPos12.y)) * w3.x * w12.y;

    result += texture(tex, vec2(texPos0.x, texPos3.y)) * w0.x * w3.y;
    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;
    result += texture(tex, vec2(texPos3.x, texPos3.y)) * w3.x * w3.y;

    return result;
}

/*
    From Playdead's Inside TAA:
    https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader
*/
vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample)
{
    // note: only clips towards aabb center (but fast!)
    vec3 p_clip = 0.5 * (aabbMax + aabbMin);
    vec3 e_clip = 0.5 * (aabbMax - aabbMin);

    vec3 v_clip = prevSample - p_clip;
    vec3 v_unit = v_clip.xyz / e_clip;
    vec3 a_unit = abs(v_unit);
    float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

    if (ma_unit > 1.0)
        return p_clip + v_clip / ma_unit;
    else
        return prevSample;// point inside aabb
}

float luminance(vec3 color) {
    return dot(color, vec3(0.2127, 0.7152, 0.0722));
}

float rcp(float f) {
    return 1.0 / f;
}

float saturate(float a) { return clamp(a, 0.0, 1.0); }
bool is_saturated(float a) { return a == saturate(a); }
bool is_saturated(vec2 a) { return a.x == saturate(a.x) &&  a.y == saturate(a.y); }
bool is_saturated(vec3 a) { return a.x == saturate(a.x) &&  a.y == saturate(a.y) &&  a.z == saturate(a.z); }

const vec2 offsets[] = {
    vec2(0, 0),
    vec2(0, 1),
    vec2(1, 0),
    vec2(1, 1)
};

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID);
    ivec2 resolution = imageSize(source);
    vec2 uv = vec2(gid) / (resolution);
    
    vec3 sourceSampleTotal = vec3(0.0);
    float sourceSampleWeight = 0.0;
    
    vec3 kernelMin = vec3(10000);
    vec3 kernelMax = vec3(-10000);

    vec3 kernelSum = vec3(0.0);
    vec3 kernelSumSquared = vec3(0.0);
    float closestDepth = 1.0;
    ivec2 closestDepthPixelPos = ivec2(0.0);

    vec4 curr = imageLoad(source, gid);
    vec4 hist = imageLoad(historyBuffer, gid);
    imageStore(resultBuffer, gid, mix(hist, curr, 0.45));
    return;

    // kernel over the current pixel
    for (int x = -1; x <= 1; x++) {

        for (int y = -1; y <= 1; y++) {

            ivec2 pos = gid + ivec2(x, y);
            pos = clamp(pos, ivec2(0), resolution.xy - 1);

            vec3 neighbor = max(vec3(0.0), imageLoad(source, pos).rgb);
            float subsampleDist = length(vec2(x, y));

            // perform black magic, a weight based on some scary looking filter function
            float subbsmapleWeight = FilterMitchellNetravali(subsampleDist);

            sourceSampleTotal += neighbor * subbsmapleWeight;
            sourceSampleWeight += subbsmapleWeight;

            kernelMin = min(kernelMin, neighbor);
            kernelMax = max(kernelMax, neighbor);

            kernelSum += neighbor;
            kernelSumSquared += neighbor * neighbor;

            float depth = texture(depthTexture, pos / resolution).r; // TODO: storage image??
            if (depth < closestDepth) {
                closestDepth = depth;
                closestDepthPixelPos = pos;
            }
        }
    }

    vec2 motionVector = imageLoad(velocityTexture, closestDepthPixelPos).xy * 0.5;

    vec2 prevUV = uv - motionVector;
    vec3 sourceSample = sourceSampleTotal / sourceSampleWeight;
    
    if (!is_saturated(prevUV)) {
        imageStore(resultBuffer, gid, vec4(sourceSample, 1.0));
        return;
    }

    vec3 prevSample = SampleTextureCatmullRom(prevResult, prevUV + (1.0 / resolution), resolution).rgb;


    float kernelAreaRcp = 1.0 / 9.0;
    vec3 kernelAvg = kernelSum * kernelAreaRcp;
    
    float gamma = 1.0;
    vec3 sigma = sqrt(abs((kernelSumSquared * kernelAreaRcp) - (kernelAvg * kernelAvg)));
    vec3 minc = kernelAvg - gamma * sigma;
    vec3 maxc = kernelAvg + gamma * sigma;

    prevSample = ClipAABB(minc, maxc, clamp(prevSample, kernelMin, kernelMax));

     imageStore(resultBuffer, gid, vec4((prevSample + sourceSample) / 2.0, 1.0));
    return;

    float sourceWeight = 0.05;
    float historyWeight = 1.0 - sourceWeight;

    vec3 compressedSource = sourceSample * rcp(max(max(sourceSample.r, sourceSample.g), sourceSample.b) + 1.0);
    vec3 compressedHistory = prevSample * rcp(max(max(prevSample.r, prevSample.g), prevSample.b) + 1.0);

    float lumSource = luminance(compressedSource);
    float lumHistory = luminance(compressedHistory);

    sourceWeight *= 1.0 / (1.0 + lumSource);
    historyWeight *= 1.0 / (1.0 + lumHistory);

    vec3 result = (sourceSample * sourceWeight + prevSample * historyWeight) / max(sourceWeight + historyWeight, 0.00001);

    imageStore(resultBuffer, gid, vec4(result, 1.0));
}